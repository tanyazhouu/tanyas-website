<!DOCTYPE html>
<html lang="en">

<head>
  <title>Tanya's Website</title>
  <link rel="stylesheet" type="text/css" href="../public/styles/styles.css" media="all" />
  <link rel="shortcut icon" type="image/x-icon" href="../public/images/caticon.ico">
  <script defer src="./js/navscript.js" type="text/Javascript"></script>
</head>

<body id="body" class="cs-page-bkg fade">
  <header class="cs-pg-hdr">
    <h1>tanya zhou</h1>
    <h3>cs portfolio: cs projects</h3>
  </header>
  <main>
    <div class="row larger-bottom">
      <nav>
        <ul>
          <li>
            <a id="abt" href="index.html">about</a>
          </li>
          <li>
            <a id="cs" href="cs-portfolio.html">cs portfolio</a>
          </li>
          <ul class="smaller-nav">
            <li class="smaller-nav">
              <a href="work-exp.html">work experience</a>
            </li>
            <li class="smaller-nav">
              <a href="cs-projects.html">projects</a>
            </li>
          </ul>
          <li>
            <a id="art" href="personal-blog.html">personal blog</a>
          </li>
        </ul>
      </nav>
      <div class="cs-proj-content">
        <p class="project-description"><em>Note: These project repositories are on both my school's GitHub profile and
            my personal
            GitHub, and due to my school's restrictions, I cannot show the repositories
            for some projects.</em></p>
        <div class="row">
          <div class="cs-proj-box">
            <h4>Front-end development</h4>
            <ul class="timeline_text bold">
              <a class="proj-link font-22" href="#personal-website">
                <li class="li-cs">Personal website</li>
              </a>
              <a class="proj-link font-22" href="#server-side">
                <li>Server-Side Rendered Plant Catalog Backed by a Database</li>
              </a>
            </ul>
          </div>
          <div class="cs-proj-box">
            <h4>Functional programming (OCaml)</h4>
            <ul class="timeline_text bold">
              <a class="proj-link font-22" href="#interpreter">
                <li class="li-cs">Interpreter for non-trivial programming language</li>
              </a>
              <a class="proj-link font-22" href="#pokemon">
                <li class="li-cs">Interactive Pokemon Game</li>
              </a>
              <a class="proj-link font-22" href="#rb">
                <li>Search Engine using Functors and Red-black trees</li>
              </a>
            </ul>
          </div>

        </div>
        <div class="row larger-bottom">
          <div class="cs-proj-box">
            <h4>C++/C</h4>
            <ul class="timeline_text bold">
              <a class="proj-link font-22" href="#handwriting">
                <li class="li-cs">Handwriting Recognition model with multi-threading</li>
              </a>
              <a class="proj-link font-22" href="#sorting-algo">
                <li>Sorting Algorithms' implementation and performance analysis</li>
              </a>
            </ul>
          </div>
          <div class="cs-proj-box">
            <h4>Java</h4>
            <ul class="timeline_text bold">
              <a class="proj-link font-22" href="#search-game">
                <li class="li-cs">Search-and-retrieve game using Hashmaps</li>
              </a>
            </ul>
          </div>
        </div>
      </div>
    </div>

    <h1 class="cs-page-title">all projects:</h1>

    <h2>Front-end development</h2>
    <div class="cs-proj-descrip">
      <a id="personal-website"></a>
      <h3><a class = "proj-link" href="https://github.com/tanyazhouu/tanyas-website">Personal website:</a></h3>
      <div class="row">
        <img src="../public/images/caticon.png" alt="Website icon (cat)">
        <div>
          <h4>Skills: HTML, CSS, Javascript, GitHub pages</h5>
            <ul class="font-22">
              <li>
                Designed personal website for front-end development/design practice
              </li>
              <li>
                Leveraged Javascript to create interactive website
              </li>
              <li>
                Hosting site via GitHub pages
              </li>
              <li>
                Looking to refactor into AngularJS app and shift to different host like AWS Beanstalk
              </li>
            </ul>
        </div>
      </div>
      <h4>Details:</h4>
      <p class="project-description">This website is my personal website to
        showcase my CS portfolio and skills and other personal
        interests in my blog. I'm currently using GitHub pages to host this
        website. For the future, I plan on refactoring this into
        an AngularJS app and moving to Heroku or AWS Beanstalk to
        include dynamic features, custom routing, and more.
      </p>
    </div>
    <div class="larger-bottom"></div>
    <div class="cs-proj-descrip">
      <a id="server-side"></a>
      <h3>Server-Side Rendered Plant Catalog Backed by a Database:</h3>
      <h4>Skills: PHP, SQL, HTML, CSS, Docker</h4>
      <ul class="font-22">
        <li>
          Designed plant catalog website and stored plant data in database
        </li>
        <li>Created custom routing and other server-side tasks with PHP</li>
        <li>Coded SQL queries for filtering and sorting options for browsing</li>
        <li>Created 'sticky' forms for user to add to plant catalog via SQL queries</li>
        <li>Coded forms to recall user's input and provide feedback for incomplete submissions</li>
      </ul>
      <b class="project-description">Details:</b>
      <div class="row">
        <p class="project-description">
          This project is a website that displays a
          plant catalog, intended for an audience to find suitable plants for
          children to play with. The data for each plant is stored
          in a database, and users can apply filters or sorting methods
          to browse through the plant catalog. SQL queries were used to
          support those filter/sort options, and PHP was used to support custom
          routing and server-side rendering.
        </p>
        <div>
          <img id="resize-600" src="../public/images/playful-plants-filter.png" alt="Plant catalog with filtering">
        </div>
      </div>
      <div class="row larger-bottom">
        <p class="project-description">
          The website also includes a form for adding a new plant to the catalog.
          If the requirements of the form are incomplete after submission, the
          user's original inputs remain, and the form provides corrective feedback.
          SQL queries were used to add this plant to the database.
        </p>
        <img id="resize-400" src="../public/images/plant-form.png" alt="Plant catalog form">
      </div>
    </div>
    <h2>Functional Programming (OCaml)</h2>
    <div class="cs-proj-descrip">
      <a id="interpreter"></a>
      <h3>Interpreter for non-trivial programming language:</h3>
      <h4>Skills: OCaml, OUnit testing, CMake</h4>
      <ul class="font-22">
        <li>Constructed syntax and interpreter of 'robot programming language' (RML)</li>
        <li>Implemented Abstract Syntax Tree to parse characters into keywords/tokens</li>
        <li>Implemented evaluator of interpreter to allow execution of RML programs</li>
        <li>Leveraged promises and concurrent programming for RML's own asynchronous expressions</li>
        <li>Unit tested code with OCaml's OUnit test framework</li>
      </ul>
      <b class="project-description">Details:</b>
      <div class="row larger-bottom">
        <div>
          <p class="project-description">
            <em>
              Background information on interpreters:</em>
            In order to implement a programming language, implementing the
            compiler or interpreter is necessary so that the computer
            is able to understand and execute the source program in that
            language. Compilers/interpreters go through multiple phases when
            translating a language: lexing, parsing, semantic analysis,
            then evaluation.
            Lexing converts the source program into tokens like keywords,
            then parsing uses those tokens to construct an Abstract Syntax Tree
            (AST), which describes the structure of the program. Semantic analysis
            then checks whether the code written is valid, and finally, the program
            is executed/evaluated.
          <p class="project-description">
            In this project, the AST was implemented to allow the lexer and parser
            to create the AST, and the evaluator was also implemented to actually
            execute programs with this language. Shown in the images are the language's REPL
            (read-evaluate-print-loop) that supports basic operations along
            with more complex expressions like variable assignment, anonymous functions
            and more.
          </p>
        </div>
        <div>
          <div>
            <p class="img-descrip">Basic operations:</p>
            <img src="../public/images/basic-op-rml.png" alt="Basic operations in programming language">
          </div>
          <div>
            <p class="img-descrip">Complex expressions:</p>
            <img src="../public/images/expressions-rml.png" alt="Expressions in RML">
          </div>
        </div>
      </div>
    </div>
    <div class="cs-proj-descrip">
      <a id="pokemon"></a>
      <h3>Interactive Pokemon Game:</h3>
      <h4>Skills: OCaml, JSON, OUnit test, CMake, ANSITerminal</h4>
      <ul class="font-22">
        <li>Created Pokemon-based game, where player travels along a map and tries to catch and fight wild Pokemon</li>
        <li>Parsed Pokemon JSON file and stored information in OCaml's record data structures</li>
        <li>Generated make-shift GUI using the terminal to display map</li>
        <li>Created modules to organize and design game's system</li>
      </ul>
      <b class="project-description">Details:</b>
      <div class="row">
        <p class="project-description">
          This Pokemon game allows users to interact, catch, and fight wild Pokemon,
          with the goal of leveling up their own Pokemon to fight stronger Pokemon.
          Collaborating with a group, I was able to design the game's system through
          modules to address game features we wanted to include. For example, a
          Map module was created to handle all the functions and interactions with
          the map in the game. In addition to modular design, we leveraged
          a pre-made JSON file storing Pokemon data to construct our Pokemon.
        </p>
        <div>
          <p class="img-descrip">Example of Pokemon battle:</p>
          <img id="resize-500" src="../public/images/fight-pokemon.png" alt="Pokemon game fight dialogue">
        </div>
      </div>
      <div class="row">
        <div>
          <p class="img-descrip">Map of game & Pokemon encounter:</p>
          <img id="resize-600" src="../public/images/map-pokemon.png" alt="Pokemon game map">
        </div>
        <div>
          <p class="img-descrip">Catching a Pokemon:</p>
          <img src="../public/images/catch-pokemon.png" alt="Pokemon game catching Pokemon">
        </div>
      </div>

      <h4>Challenges:</h4>
      <p class="project-description">
        A major portion of the game is the Graphical User Interface (GUI), and
        due to time constraints for the project, we decided to do a terminal-based
        map as a work-around, allowing the player to explore the map more. Another
        challenge we encountered was issues with mutability; for instance, if
        a Pokemon lost health during a battle, the Pokemon's health would return
        to its original value after the battle. So maintaining effects after changes
        were made to Pokemon was one issue we often encountered.
      </p>
      <div class="larger-bottom">
      </div>
    </div>
    <div class="cs-proj-descrip">
      <a id="rb"></a>
      <h3>Search Engine using Functors and Red-black trees:</h3>
      <h4>Skills: OCaml, Functors, OUnit Testing</h4>
      <ul class="font-22">
        <li>
          Created search engine to query for words in directories with text files
        </li>
        <li>
          Constructed dictionary interface using Red-black trees and OCaml association lists to
          observe differences in performance
        </li>
        <li>
          Designed a set data structure interface using a functor that required dictionary
          data structure to construct the set
        </li>
        <li>
          Leveraged functors for OUnit testing and OCaml's 'Bisect' tool for analyzing tests' code-coverage
        </li>
      </ul>

      <h4>Details:</h4>
      <div class="row">
        <div>
          <p class="project-description">
            This search engine returns the names of text files that include
            the words in the provided query. Different queries can be entered
            to obtain results; the "and" query followed by some words will
            look for files that contain all words in the query, while the "or" query
            will look for files that contain <em>any</em> of the words in the query.
            The queries can also include "not" words, in which if files contain
            the words of the "not" query, they will be excluded from the search result.
          </p>
          <p class="project-description">
            In building the search engine, a dictionary interface was created using both
            an OCaml association list (linked list) approach and a tree-based approach.
            The association list approach uses keys and values to create the dictionary
            and leverages OCaml's higher order functions like "fold_left" or "map" to
            satisfy required dictionary functions. The tree-based approach uses a "Leaf" type
            and a "Node" type, containing the node's color (red or black), key-value pair,
            and a left child and right child. This tree-based approach for the search engine
            yields better performance due to the logarithmic performance it provides in its
            operations.
          </p>
        </div>
        <div>
          <p class="img-descrip">Use of functors to create the engine:</p>
          <img id="resize-500" src="../public/images/engine-make-functor-search.png" alt="Picture of example functor">
          <p class="img-descrip">Organized unit tests with modules:</p>
          <img id="resize-400" src="../public/images/tests-search.png" alt="Functors used for testing">
          <p class="img-descrip">Code coverage using bisect:</p>
          <img src="../public/images/bisect-test.png" alt="Image of code coverage">
        </div>
      </div>

    </div>
    <h2>C++/C</h2>
    <div class="cs-proj-descrip">
      <a id="handwriting"></a>
      <h3>Handwriting recognition model with multi-threading:</h3>
      <h4>Skills: C++, Python, Linux, CMake, Git</h4>
      <ul class="font-22">
        <li>Implemented supervised model that classified images of handwritten digits from a dataset by comparing the
          image's intensity to the training set's intensities.</li>
        <li>Organized binary tree and vector data structures via classes, and ptimized methods using function inlining,
          memoization, and reduction of overall overhead. Used flame graphs to guide optimizations.
        </li>
        <li>Binary, linear, and multi-threaded search algorithms were implemented for classification.</li>
        <li>Analyzed performance and accuracy of each algorithm then characterized measured data with complexity
          analyses
          done in big-O notation.</li>
        <li>Used bash scripts to automate evaluations and Python to visualize the results to compare data.</li>
      </ul>
      <h4>Details:</h4>
      <div class="row">
        <div>
          <p class="project-description">
            This involved creating four supervised learning models that
            train and classify images of handwritten digits; HRSLinearSearch,
            HRSBinarySearch, HRSTreeSearch, and the alternative system (Parallel
            Linear Search) all rely on the generic resizable <code>Vector</code> and generic
            sort algorithm, class <code>Image</code>, and generic <code>Tree</code> data structure.
            HRSLinear, HRSBinary, and the alternative store a <code>Vector</code> as their set of
            training data and each use different implementations to classify the
            set of images passed in.</p>
        </div>
        <div>
          <p class="img-descrip">Graph comparing accuracy and execution times of each model:</p>
          <img src="../public/images/p1-data.png" alt="Data Analysis for CS project">
        </div>
      </div>
      <div>
        <p class="project-description">HRSLinear uses a linear search algorithm
          and HRSBinary sorts then uses a binary search. The concurrent
          alternative system creates a thread for each partition of the
          training data then performs a linear search per partition.
          HRSTreeSearch stores the training data in a <code>Tree</code> and
          classifies an Image by using intensity to search and traverse
          through the tree and at a certain level determined by a K parameter, performs
          an exhaustive search using an image's distance to compare for that subtree.</p>
      </div>
      <div class="larger-bottom"></div>
      <a id="sorting"></a>
      <h3>Sorting algorithms' implementation and performance analysis:</h3>
      <h4>Skills: C++, Linux, CMake, Git</h4>
      <ul class="font-22">
        <li>Implemented insertion, selection, merge, quick, and bucket sort, and tested via directed tests and random
          tests.
        </li>
        <li>Quantitatively evaluated each algorithm by inputting variable-length arrays and graphed measured execution
          times
        </li>
        <li>Recorded memory usage (auxiliary heap space usage) for each test for further analysis</li>
        <li>Leveraged bash scripts to automate testing and analyses</li>
        <li>
          Performance and memory usage were characterized via complexity analyses.
        </li>
      </ul>
      <h4>Details:</h4>
      <div class="row">
        <div>
          <p class="project-description">
            This project investigates different sorting algorithms,
            selection sort, merge sort, quick sort, and bucket sort,
            and the respective performance and heap space usage differences between
            each of them.
            This is to provide insight into which algorithm may perform better
            in certain situations; for instance, if memory resources are limited,
            one would opt to use a memory-efficient sorting algorithm. The
            graphs on the side display the average execution times and heap
            space usage for each algorithm given an input array size to sort (number of elements).
          </p>
        </div>
        <div>
          <img id="resize-500" src="../public/images/avg-exec-time-data.png"
            alt="Execution time data for sorting algorithm">
          <img id="resize-500" src="../public/images/aux-heap-space-data.png"
            alt="Memory usage data for sorting algorithms">
        </div>

      </div>
      <h4>Analysis:</h4>
      <p class="project-description"> Complexity analyses in terms of time and auxiliary heap space
        usage were also done, providing insight into which algorithm may
        be preferred over others in certain scenarios.
        Selection sort and bucket sort demonstrated quadratic time
        complexity but merge and quick sort had loglinear time complexity.
        As for space usage, selection and quick sort had constant space usage,
        while the other two had linear space usage. Quantitative evaluations
        performed via prewritten evaluation programs were also used to plot
        execution times and auxiliary heap space usage for different array sizes
        for each of the sorting algorithms, which visualized the differences
        between algorithms and solidified individual drawbacks or advantages.
        From the analyses and evaluations, merge sort and quick sort seem
        to be the ideal sorting algorithms given their average loglinear
        performance and space usage.</p>
      <p class="img-descrip">Table showing data collected on each sorting algorithm:</p>
      <img id="resize-800" src="../public/images/sorting-data-analysis.png"
        alt="Results from sorting algorithm analysis">
    </div>
    <div class="larger-bottom"></div>
    <h2>Java</h2>
    <div class="cs-proj-descrip">
      <a id="search-game"></a>
      <h3>Search-and-retrieve game using Hashmaps:</h3>
      <h4>Skills: Java, JUnit, Java Swing</h4>
      <ul class="font-22">
        <li>Game involved searching for a ring in the smallest number of steps in a randomized maze then upon retrieval,
          returning to the exit collecting as many coins as possible.</li>
        <li>Leveraged HashMaps, Sets, and other built-in Java Collections to store information about neighboring nodes
          and
          their distances to the exit and ring</li>
        <li>Implemented and tested depth-first search based algorithms to explore maze</li>
        <li>Implemented Dijkstra's shortest path algorithm to calculate shortest path from current location to exit.
        </li>
      </ul>
      <h4>Details:</h4>
      <div class="row">
        <div>
          <p class="project-description">
            This project involved developing algorithms that drove a small search-and-retrieve
            type game, in which a character must first 'search' for a ring in a maze then upon
            retrieval, the character must return to the exit of the maze while collecting the
            maximum number of coins that they can. The algorithms that
            powered the character's movements were all tree-based algorithms and each
            relied on data structures to store information.
          </p>
        </div>
        <div>
          <img src="../public/images/game-scram_ccexpress.png" alt="Image of Java Game">
        </div>
      </div>
      <p class="project-description">
        This involved splitting the project up into two phases: a 'seek' phase
        and a 'scram' phase, where the character first must find the ring then
        run out of the maze. The 'seek' phase's problem mainly dealt with
        developing an algorithm that found the ring in the shortest number of
        steps in order to maximize the character's score; the more steps
        they took to find the ring meant a smaller score multiplier. Similarly,
        the "scram" phase required maximizing the number of coins collected while
        exiting and exiting within the prescribed number of steps.
        Each of these algorithms relied on a depth-first-search (DFS) algorithm
        and the "scram" phase implemented Dijkstra's algorithm once the character
        reached a threshold number of steps.
      </p>
      <div class="larger-bottom"></div>

  </main>
</body>
<footer>
</footer>